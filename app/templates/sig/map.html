{% extends 'base.html' %}
{% block content %}
  <style>
    html, body { height: 100%; }
    main.container { max-width: 100% !important; padding: 0; }
    .map-wrapper { display: flex; height: calc(100vh - 64px); width: 100%; }
    .sidebar { width: 300px; background: #fff; border-right: 1px solid #e5e7eb; padding: 12px; overflow: auto; }
    .sidebar h2 { font-size: 1rem; margin: 0 0 8px; font-weight: 700; }
    .sidebar .section { margin-bottom: 14px; }
    .sidebar .muted { color: #6c757d; font-size: .9rem; }
    .sidebar .list { list-style: none; padding: 0; margin: 0; }
    .sidebar .list li { display: flex; align-items: center; justify-content: space-between; padding: 6px 0; border-bottom: 1px dashed #eee; }
    #map { flex: 1; }
    /* Enhancements: spacing, actions, toggle */
    .map-wrapper { position: relative; }
    .sidebar .list li { gap: 8px; }
    .sidebar .item-actions { display: flex; gap: 6px; }
    .sidebar .btn-icon { border: 1px solid #e5e7eb; background: #f8f9fa; padding: 2px 6px; border-radius: 4px; font-size: 12px; cursor: pointer; }
    .sidebar .btn-icon:hover { background: #e9ecef; }
    .sidebar-toggle { position: absolute; left: 300px; top: 12px; z-index: 500; transform: translateX(-50%); }
    .sidebar-toggle .btn { padding: 4px 8px; font-size: 12px; }
    .collapsed .sidebar { width: 0; padding: 0; border-right: none; }
    .collapsed .sidebar-toggle { left: 0; transform: translateX(-50%); }
    .leaflet-top.leaflet-right { margin-right: 10px; }
    .leaflet-top.leaflet-left { margin-left: 10px; }
  </style>
  <div class="map-wrapper">
    <aside class="sidebar">
      <div class="section">
        <h2>Camada base</h2>
        <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-road" value="road" checked><label class="form-check-label" for="bm-road">Rodoviário</label></div>
        <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-sat" value="sat"><label class="form-check-label" for="bm-sat">Satélite</label></div>
        <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-relief" value="relief"><label class="form-check-label" for="bm-relief">Relevo</label></div>
      </div>
      <div class="section">
        <h2>Meus GeoJSONs</h2>
        <ul id="layers-list" class="list"></ul>
        <p class="muted" id="no-layers" style="display:none">Nenhum arquivo. Envie um abaixo.</p>
      </div>
      <div class="section">
        <h2>Novo GeoJSON</h2>
        <form id="upload-form">
          <div class="mb-2"><input class="form-control form-control-sm" type="text" name="name" placeholder="Nome opcional" /></div>
          <div class="mb-2"><input class="form-control form-control-sm" type="file" name="file" accept=".json,.geojson,application/geo+json,application/json" required /></div>
          <button class="btn btn-primary btn-sm" type="submit">Carregar</button>
          <div class="form-text">Somente você verá/manipulará seus arquivos.</div>
        </form>
      </div>
    </aside>
    <div id="map"></div>
    <div class="sidebar-toggle">
      <button type="button" id="btn-toggle-sidebar" class="btn btn-light border">⟨⟩</button>
    </div>
  </div>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script>
    const map = L.map('map', { zoomControl: false });
    L.control.zoom({ position: 'topright' }).addTo(map);
    // Base layers
    const baseLayers = {
      road: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'}),
      sat: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {attribution: 'Tiles &copy; Esri'}),
      relief: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {maxZoom: 17, attribution: 'Map data: &copy; OpenStreetMap, SRTM | Map style: &copy; OpenTopoMap'})
    };
    baseLayers.road.addTo(map);
    map.setView([0, 0], 2);

    // Draw tools and editable group
    const editableGroup = new L.FeatureGroup();
    map.addLayer(editableGroup);
    const drawControl = new L.Control.Draw({
      edit: { featureGroup: editableGroup },
      draw: { polygon: true, polyline: true, rectangle: true, circle: true, marker: true }
    });
    map.addControl(drawControl);
    map.on(L.Draw.Event.CREATED, function (e) { editableGroup.addLayer(e.layer); });

    // My GeoJSON layers state
    const userLayers = new Map(); // id -> layer
    let currentItems = [];

    function renderList() {
      const list = document.getElementById('layers-list');
      const no = document.getElementById('no-layers');
      list.innerHTML = '';
      if (!currentItems.length) { no.style.display = 'block'; return; } else { no.style.display = 'none'; }
      currentItems.forEach(item => {
        const li = document.createElement('li');
        const label = document.createElement('label');
        label.className = 'form-check-label d-flex align-items-center gap-2 flex-grow-1';
        const chk = document.createElement('input');
        chk.className = 'form-check-input me-2';
        chk.type = 'checkbox';
        chk.checked = true;
        chk.addEventListener('change', () => {
          const layer = userLayers.get(item.id);
          if (!layer) return;
          if (chk.checked) { layer.addTo(map); } else { map.removeLayer(layer); }
        });
        label.appendChild(chk);
        label.appendChild(document.createTextNode(item.name));
        li.appendChild(label);
        const actions = document.createElement('div');
        actions.className = 'item-actions';
        const btnZoom = document.createElement('button');
        btnZoom.type = 'button';
        btnZoom.className = 'btn-icon';
        btnZoom.textContent = 'Zoom';
        btnZoom.addEventListener('click', () => {
          const layer = userLayers.get(item.id);
          if (layer) {
            try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch (e) {}
          }
        });
        const btnEdit = document.createElement('button');
        btnEdit.type = 'button';
        btnEdit.className = 'btn-icon';
        btnEdit.textContent = 'Editar';
        btnEdit.addEventListener('click', () => { startEdit(item.id); });
        actions.appendChild(btnZoom);
        actions.appendChild(btnEdit);
        li.appendChild(actions);
        list.appendChild(li);
      });
    }

    function addOrReplaceLayer(item) {
      // remove existing
      const existing = userLayers.get(item.id);
      if (existing) { map.removeLayer(existing); editableGroup.removeLayer(existing); }
      const layer = L.geoJSON(item.data, { style: { color: '#0d6efd' } }).bindPopup(`<strong>${item.name}</strong>`);
      userLayers.set(item.id, layer);
      layer.addTo(map);
      editableGroup.addLayer(layer);
      return layer;
    }

    function fitToAll() {
      const group = L.featureGroup([...userLayers.values()]);
      if (group.getLayers().length) { map.fitBounds(group.getBounds(), { padding: [20, 20] }); }
    }

    function loadItems() {
      return fetch("{{ url_for('sig.api_my_geojsons') }}")
        .then(r => r.json())
        .then(items => {
          currentItems = Array.isArray(items) ? items : [];
          currentItems.forEach(addOrReplaceLayer);
          renderList();
          fitToAll();
        })
        .catch(() => {});
    }

    // Basemap switching
    document.querySelectorAll('input[name="basemap"]').forEach(r => {
      r.addEventListener('change', () => {
        // remove all base layers then add selected
        Object.values(baseLayers).forEach(l => map.removeLayer(l));
        baseLayers[r.value].addTo(map);
      });
    });

    // Upload handler
    document.getElementById('upload-form').addEventListener('submit', async (ev) => {
      ev.preventDefault();
      const form = ev.currentTarget;
      const fd = new FormData(form);
      const resp = await fetch("{{ url_for('sig.api_upload') }}", { method: 'POST', body: fd });
      if (!resp.ok) { alert('Falha ao enviar arquivo'); return; }
      const item = await resp.json();
      // update state
      currentItems.push(item);
      addOrReplaceLayer(item);
      renderList();
      fitToAll();
      form.reset();
    });

    // Sidebar toggle
    const wrapper = document.querySelector('.map-wrapper');
    const btnToggle = document.getElementById('btn-toggle-sidebar');
    btnToggle.addEventListener('click', () => {
      wrapper.classList.toggle('collapsed');
      setTimeout(() => map.invalidateSize(), 220);
    });

    // Back button control
    const BackControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function() {
        const container = L.DomUtil.create('div', 'leaflet-bar');
        const a = L.DomUtil.create('a', '', container);
        a.href = '#'; a.title = 'Voltar'; a.innerHTML = '↩';
        L.DomEvent.on(a, 'click', L.DomEvent.stopPropagation)
                  .on(a, 'click', L.DomEvent.preventDefault)
                  .on(a, 'click', () => { if (history.length > 1) history.back(); else window.location = "{{ url_for('sig.index') }}"; });
        return container;
      }
    });
    map.addControl(new BackControl());

    // --- Edit session control (Salvar / Cancelar) ---
    const EditSessionControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function() {
        const container = L.DomUtil.create('div', 'leaflet-bar');
        container.style.display = 'none'; // hidden by default
        const btnSave = L.DomUtil.create('a', '', container);
        btnSave.href = '#'; btnSave.title = 'Salvar edições'; btnSave.innerHTML = '💾';
        const btnCancel = L.DomUtil.create('a', '', container);
        btnCancel.href = '#'; btnCancel.title = 'Cancelar edições'; btnCancel.innerHTML = '✖';
        L.DomEvent.on(btnSave, 'click', L.DomEvent.stopPropagation)
                  .on(btnSave, 'click', L.DomEvent.preventDefault)
                  .on(btnSave, 'click', onSaveEdits);
        L.DomEvent.on(btnCancel, 'click', L.DomEvent.stopPropagation)
                  .on(btnCancel, 'click', L.DomEvent.preventDefault)
                  .on(btnCancel, 'click', onCancelEdits);
        this._container = container;
        return container;
      },
      setVisible: function(v) {
        if (this._container) this._container.style.display = v ? '' : 'none';
      }
    });
    const editSessionControl = new EditSessionControl();
    map.addControl(editSessionControl);

    // --- Edit session logic ---
    let editingItemId = null;
    let originalGeoJSON = null;
    let editedDirty = false;
    const apiUpdateBase = "{{ url_for('sig.api_update_file', file_id=0) }}"; // e.g. /sig/api/files/0
    function updateUrl(id) { return apiUpdateBase.replace(/0$/, String(id)); }

    map.on('draw:edited', () => { editedDirty = true; });

    function enableDrawEditMode() {
      try {
        if (drawControl && drawControl._toolbars && drawControl._toolbars.edit && drawControl._toolbars.edit._modes.edit) {
          drawControl._toolbars.edit._modes.edit.handler.enable();
        }
      } catch (e) {}
    }

    function disableDrawEditMode() {
      try {
        if (drawControl && drawControl._toolbars && drawControl._toolbars.edit && drawControl._toolbars.edit._modes.edit) {
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
      } catch (e) {}
    }

    function startEdit(itemId) {
      if (editingItemId && editingItemId !== itemId) {
        alert('Já existe uma edição em andamento. Salve ou cancele antes de editar outra camada.');
        return;
      }
      const item = currentItems.find(it => it.id === itemId);
      const layer = userLayers.get(itemId);
      if (!item || !layer) return;
      // snapshot original
      originalGeoJSON = JSON.parse(JSON.stringify(item.data));
      editingItemId = itemId;
      editedDirty = false;
      // isolate in editable group (ensure child vectors are target of edit)
      editableGroup.clearLayers();
      if (typeof layer.getLayers === 'function') {
        layer.getLayers().forEach(ch => editableGroup.addLayer(ch));
      } else {
        editableGroup.addLayer(layer);
      }
      try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch (e) {}
      enableDrawEditMode();
      editSessionControl.setVisible(true);
    }

    async function onSaveEdits() {
      if (!editingItemId) return;
      const layer = userLayers.get(editingItemId);
      if (!layer) { onCancelEdits(); return; }
      const updated = layer.toGeoJSON();
      try {
        const resp = await fetch(updateUrl(editingItemId), {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ data: updated })
        });
        if (!resp.ok) {
          const msg = await resp.text();
          alert('Falha ao salvar: ' + msg);
          return;
        }
        const saved = await resp.json();
        // update local state
        const idx = currentItems.findIndex(it => it.id === editingItemId);
        if (idx >= 0) currentItems[idx] = saved;
        // replace layer with saved data to ensure consistency
        addOrReplaceLayer(saved);
        finishEditSession();
        renderList();
      } catch (e) {
        alert('Erro inesperado ao salvar.');
      }
    }

    function onCancelEdits() {
      if (!editingItemId) return;
      // restore original geometry
      const restored = { id: editingItemId, name: (currentItems.find(it => it.id === editingItemId) || {}).name || 'Sem nome', data: originalGeoJSON };
      addOrReplaceLayer(restored);
      finishEditSession();
    }

    function finishEditSession() {
      disableDrawEditMode();
      editSessionControl.setVisible(false);
      editingItemId = null;
      originalGeoJSON = null;
      editedDirty = false;
      // keep editableGroup containing all layers again
      editableGroup.clearLayers();
      [...userLayers.values()].forEach(l => editableGroup.addLayer(l));
    }

    // Initial load
    loadItems().then(() => {
      // Focus layer via query param ?focus=<id>
      const sp = new URLSearchParams(location.search);
      const focusId = parseInt(sp.get('focus') || '', 10);
      if (!isNaN(focusId)) {
        const layer = userLayers.get(focusId);
        if (layer) {
          try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch (e) {}
        }
      }
    });
  </script>
{% endblock %}

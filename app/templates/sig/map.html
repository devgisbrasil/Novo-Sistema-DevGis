{% extends 'base.html' %}
{% block content %}
  <style>
    html, body { height: 100%; }
    main.container { max-width: 100% !important; padding: 0; margin-top: 0 !important; }
    .map-wrapper { display: flex; height: calc(100vh - 56px); width: 100%; }
    
    /* Style for the save control */
    .leaflet-bar a.leaflet-bar-part {
      background-color: #fff;
      border-bottom: 1px solid #ccc;
      width: 30px;
      height: 30px;
      line-height: 30px !important;
      display: flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      color: #333;
    }
    
    .leaflet-bar a.leaflet-bar-part:hover {
      background-color: #f4f4f4;
    }
    
    .leaflet-bar a.leaflet-bar-part i {
      font-size: 16px;
    }
    /* Updated sidebar styles */
    .sidebar {
      width: 300px;
      background: #2D3748; /* Dark background */
      color: #E2E8F0; /* Light text */
      padding: 16px;
      overflow-y: auto;
      overflow-x: hidden;
      transition: width 0.3s ease, padding 0.3s ease;
      box-shadow: 3px 0 10px rgba(0,0,0,0.1);
    }
    .sidebar h2 {
      font-size: 1rem;
      margin: 0;
      font-weight: 600;
      color: #fff; /* White for headers */
    }
    .sidebar .section {
      margin-bottom: 16px;
      padding: 12px;
      background: rgba(255,255,255,0.05); /* Slight contrast for sections */
      border-radius: 8px;
    }
    .sidebar .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 12px;
    }
    .sidebar .section-header .badge {
      background: #4A5568; /* Darker badge */
      color: #fff;
    }
    .sidebar hr {
      margin: 16px 0;
      border-color: #4A5568; /* Darker separator */
    }
    .sidebar .muted {
      color: #A0AEC0; /* Muted text */
      font-size: 0.9rem;
    }
    .sidebar .list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .sidebar .list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid #4A5568; /* Darker border */
      flex-wrap: wrap;
    }
    .sidebar .item-label {
      min-width: 0;
      flex: 1 1 100%;
      display: flex;
      align-items: center;
      gap: 12px; /* Increased gap */
    }
    .sidebar .item-label .name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: inline-block;
      max-width: 160px;
      color: #E2E8F0; /* Light text */
    }
    .sidebar .item-actions {
      display: flex;
      align-items: center;
      gap: 8px; /* Increased gap */
      width: 100%;
      margin-top: 8px;
    }
    .sidebar .item-actions .btn-ico {
      flex: 0 0 auto;
      background: #4A5568; /* Darker button */
      color: #fff;
      border: none;
    }
    .sidebar .item-actions .btn-ico:hover {
      background: #718096; /* Lighter on hover */
    }
    .btn-ico {
      width: 32px; /* Slightly larger */
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      border-radius: 6px;
      font-size: 14px;
    }
    .sidebar .section-box {
      background: rgba(255,255,255,0.05); /* Slight contrast */
      border: 1px solid #4A5568; /* Darker border */
      border-radius: 8px;
      padding: 12px;
    }
    /* Add icons to section headers */
    .section-header h2::before {
      font-family: "Font Awesome 6 Free";
      display: inline-block;
      margin-right: 8px;
      font-weight: 900;
    }
    .section-basemap h2::before {
      content: "\f0ac"; /* Globe icon */
    }
    .section-layers h2::before {
      content: "\f5fd"; /* Layer group icon */
    }
    .section-upload h2::before {
      content: "\f093"; /* Upload icon */
    }
    /* Adjust the toggle button */
    .sidebar-toggle .btn {
      background: #4A5568;
      color: #fff;
      border: none;
    }
    .sidebar-toggle .btn:hover {
      background: #718096;
    }
    #map { flex: 1; }
    /* Enhancements: spacing, actions, toggle */
    .map-wrapper { position: relative; }
    .sidebar .list li { gap: 8px; }
    .sidebar .item-actions { display: flex; gap: 6px; }
    .sidebar .btn-icon { border: 1px solid #e5e7eb; background: #f8f9fa; padding: 2px 6px; border-radius: 4px; font-size: 12px; cursor: pointer; }
    .sidebar .btn-icon:hover { background: #e9ecef; }
    .sidebar-toggle { position: absolute; left: 300px; top: 50%; z-index: 500; transform: translateX(-50%) translateY(-50%); }
    .sidebar-toggle .btn { padding: 8px 10px; font-size: 14px; border-radius: 999px; box-shadow: 0 2px 8px rgba(0,0,0,.15); }
    .sidebar-toggle .btn.btn-primary { background: var(--brand-500); border-color: var(--brand-600); }
    .sidebar-toggle .btn.btn-primary:hover { background: var(--brand-600); border-color: var(--brand-700); }
    .collapsed .sidebar { width: 0; padding: 0; border-right: none; }
    .collapsed .sidebar-toggle { left: 0; transform: translateX(-50%); }
    .leaflet-top.leaflet-right { margin-right: 10px; }
    .leaflet-top.leaflet-left { margin-left: 10px; }
    /* Upload nicer visuals */
    .dropzone { border: 2px dashed #cbd5e1; border-radius: 8px; padding: 10px; background: #fff; text-align: center; color: #64748b; }
    .dropzone.dragover { background: #f1f5f9; border-color: #94a3b8; }
    .form-help { font-size: .85rem; color: #6c757d; }
  </style>
  <div class="map-wrapper">
    <aside class="sidebar">
      <div class="section section-box section-basemap">
        <div class="section-header">
          <h2>Camada base</h2>
          <button class="btn btn-sm btn-outline-secondary" type="button" data-collapse="#sec-basemap">Ocultar</button>
        </div>
        <div id="sec-basemap">
          <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-road" value="road" checked><label class="form-check-label" for="bm-road">OSM (Rodovi√°rio)</label></div>
          <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-sat" value="sat"><label class="form-check-label" for="bm-sat">Esri Sat√©lite</label></div>
          <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-relief" value="relief"><label class="form-check-label" for="bm-relief">OpenTopo (Relevo)</label></div>
          <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-esri-street" value="esri_street"><label class="form-check-label" for="bm-esri-street">Esri Ruas</label></div>
          <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-esri-topo" value="esri_topo"><label class="form-check-label" for="bm-esri-topo">Esri Topo</label></div>
          <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-carto-pos" value="carto_pos"><label class="form-check-label" for="bm-carto-pos">Carto Positron</label></div>
          <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-carto-dark" value="carto_dark"><label class="form-check-label" for="bm-carto-dark">Carto DarkMatter</label></div>
        </div>
      </div>
      <hr />
      <div class="section section-box section-layers">
        <div class="section-header">
          <h2>Minhas camadas</h2>
          <span class="badge rounded-pill" id="layer-count">0</span>
        </div>
        <div class="mb-2">
          <input type="text" id="layer-search" class="form-control form-control-sm" placeholder="Buscar camada..." />
        </div>
        <ul id="layers-list" class="list"></ul>
        <p class="muted" id="no-layers" style="display:none">Nenhum arquivo. Envie um abaixo.</p>
      </div>
      <hr />
      <div class="section section-box section-upload">
        <div class="section-header">
          <h2>Novo GeoJSON</h2>
          <div class="d-flex gap-2">
            <button id="btn-show-upload" class="btn btn-sm btn-success" type="button">Inserir nova camada</button>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-collapse="#sec-upload">Ocultar</button>
          </div>
        </div>
        <div id="sec-upload" style="display:none">
          <div class="mb-2 form-help">Envie um arquivo .geojson/.json ou arraste e solte abaixo.</div>
          <form id="upload-form" class="mb-2">
            <div class="mb-2"><input class="form-control form-control-sm" type="text" name="name" placeholder="Nome da camada (opcional)" /></div>
            <div id="dropzone" class="dropzone mb-2">
              <i class="fa-solid fa-file-arrow-up me-2"></i>Arraste o arquivo aqui ou clique no campo abaixo
            </div>
            <div class="mb-2"><input id="file-input" class="form-control form-control-sm" type="file" name="file" accept=".json,.geojson,application/geo+json,application/json" required /></div>
            <button class="btn btn-primary btn-sm w-100" type="submit"><i class="fa-solid fa-upload me-2"></i>Carregar</button>
          </form>
        </div>
      </div>
      <hr />
      <div class="section section-box">
        <div class="section-header">
          
        </div>
      </div>
      <hr />
    </aside>
    <div id="map"></div>
    <div class="sidebar-toggle">
      <button type="button" id="btn-toggle-sidebar" class="btn btn-primary" title="Recolher/Expandir menu">
        <span id="icon-open">¬´</span><span id="icon-closed" style="display:none">¬ª</span>
      </button>
    </div>
  </div>

  <!-- Modal: Tabela de Atributos -->
  <div class="modal fade" id="attrModal" tabindex="-1" aria-labelledby="attrModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="attrModalLabel">Tabela de atributos</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="d-flex gap-2 mb-2">
            <button class="btn btn-outline-primary btn-sm" id="btn-add-col">Adicionar campo</button>
            <button class="btn btn-outline-danger btn-sm" id="btn-del-col">Remover campo selecionado</button>
            <span class="text-muted">Dica: clique em um cabe√ßalho para selecionar a coluna.</span>
          </div>
          <div class="table-responsive">
            <table class="table table-bordered table-sm align-middle" id="attr-table">
              <thead></thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
          <button type="button" class="btn btn-primary" id="btn-save-attrs">Salvar altera√ß√µes</button>
        </div>
      </div>
    </div>
  </div>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script>
    const map = L.map('map', { zoomControl: false });
    L.control.zoom({ position: 'topright' }).addTo(map);
    // Base layers
    const baseLayers = {
      road: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'}),
      sat: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {maxZoom: 20, attribution: 'Tiles &copy; Esri'}),
      relief: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {maxZoom: 17, attribution: 'Tiles &copy; OpenTopoMap'}),
      esri_street: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {maxZoom: 20, attribution: 'Tiles &copy; Esri'}),
      esri_topo: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {maxZoom: 20, attribution: 'Tiles &copy; Esri'}),
      carto_pos: L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {subdomains: 'abcd', maxZoom: 19, attribution: '&copy; CartoDB'}),
      carto_dark: L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png', {subdomains: 'abcd', maxZoom: 19, attribution: '&copy; CartoDB'})
    };
    baseLayers.road.addTo(map);

    const editableGroup = new L.FeatureGroup();
    map.addLayer(editableGroup);
    const drawControl = new L.Control.Draw({
      position: 'topleft',
      draw: { 
        polygon: { 
          allowIntersection: false,
          showArea: true,
          metric: true,
          shapeOptions: {
            color: '#3388ff',
            weight: 2,
            fillOpacity: 0.2
          }
        }, 
        polyline: {
          shapeOptions: {
            color: '#3388ff',
            weight: 5,
            opacity: 0.7
          }
        }, 
        rectangle: {
          shapeOptions: {
            color: '#3388ff',
            weight: 2,
            fillOpacity: 0.2
          }
        }, 
        circle: false, 
        marker: {
          icon: L.icon({
            iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            shadowSize: [41, 41]
          })
        } 
      },
      edit: { 
        featureGroup: editableGroup,
        remove: true
      }
    });
    
    // Add draw control to map
    map.addControl(drawControl);
    
    // Handle drawing events
    map.on(L.Draw.Event.CREATED, function (e) {
      const layer = e.layer;
      editableGroup.addLayer(layer);
      
      // Add popup with feature info
      const type = e.layerType;
      const props = layer.feature?.properties || {};
      const coords = JSON.stringify(layer.getLatLng ? layer.getLatLng() : layer.getBounds());
      
      let popupContent = `<div><b>Novo ${type}</b><br>`;
      popupContent += `<small>Coordenadas: ${coords}</small>`;
      
      if (Object.keys(props).length > 0) {
        popupContent += '<br>Propriedades:<ul>';
        for (const [key, value] of Object.entries(props)) {
          popupContent += `<li><b>${key}:</b> ${value}</li>`;
        }
        popupContent += '</ul>';
      }
      
      layer.bindPopup(popupContent);
    });
    
    // Add save button for drawn features
    const SaveControl = L.Control.extend({
      options: {
        position: 'topleft'
      },
      
      onAdd: function(map) {
        console.log('Initializing save control');
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
        const link = L.DomUtil.create('a', 'leaflet-bar-part', container);
        link.href = '#';
        link.title = 'Salvar desenho como camada';
        link.innerHTML = '<i class="fas fa-save" style="line-height: 30px;"></i>';
        
        // Store map reference
        this._map = map;
        
        // Add click handler
        const onClick = (e) => {
          console.log('Save button clicked (direct handler)');
          L.DomEvent.stopPropagation(e);
          L.DomEvent.preventDefault(e);
          this._saveDrawnFeatures();
        };
        
        // Add event listeners
        L.DomEvent.on(link, 'click', onClick);
        L.DomEvent.on(link, 'dblclick', L.DomEvent.stopPropagation);
        
        // Make link focusable and add keyboard support
        link.tabIndex = 0;
        link.setAttribute('role', 'button');
        link.setAttribute('aria-label', 'Salvar desenho');
        
        console.log('Save control initialized');
        return container;
      },
      
      _saveDrawnFeatures: async function() {
        console.log('Save button clicked');
        console.log('Editable layers count:', editableGroup.getLayers().length);
        
        if (editableGroup.getLayers().length === 0) {
          console.log('No layers to save');
          alert('Nenhum desenho para salvar. Desenhe algo no mapa primeiro.');
          return;
        }
        
        const name = prompt('Nome da nova camada:', 'Meu Desenho');
        console.log('User entered name:', name);
        if (!name) {
          console.log('User cancelled save');
          return;
        }
        
        // Create a feature collection from drawn layers
        const features = [];
        editableGroup.getLayers().forEach(layer => {
          if (layer.toGeoJSON) {
            const geoJson = layer.toGeoJSON();
            // Preserve any properties that were added to the feature
            if (layer.feature && layer.feature.properties) {
              geoJson.properties = { ...layer.feature.properties };
            }
            features.push(geoJson);
          }
        });
        
        if (features.length === 0) {
          alert('Nenhum desenho v√°lido para salvar.');
          return;
        }
        
        const featureCollection = {
          type: 'FeatureCollection',
          features: features
        };
        
        try {
          // Send to server
          const response = await fetch('/sig/api/upload', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              name: name,
              data: featureCollection
            })
          });
          
          if (!response.ok) {
            const error = await response.text();
            throw new Error(error || 'Falha ao salvar o desenho');
          }
          
          const result = await response.json();
          alert('Desenho salvo com sucesso!');
          
          // Clear the drawn features
          editableGroup.clearLayers();
          
          // Reload the layers list
          loadItems();
          
        } catch (error) {
          console.error('Error saving drawing:', error);
          alert(`Erro ao salvar o desenho: ${error.message}`);
        }
      }
    });
    
    // Track if we're in drawing mode
    let isDrawingMode = false;
    
    // Add a dedicated save button to the map controls
    const saveControl = L.control({position: 'topleft'});
    
    saveControl.onAdd = function(map) {
      const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
      div.innerHTML = `
        <a href="#" class="leaflet-draw-edit-edit" title="Salvar Desenho" style="display: block;">
          <i class="fas fa-save" style="line-height: 30px; width: 30px; text-align: center; display: inline-block;"></i>
        </a>
      `;
      
      // Add click handler
      L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation)
        .on(div, 'click', L.DomEvent.preventDefault)
        .on(div, 'click', async () => {
          const layers = editableGroup.getLayers();
          if (layers.length === 0) {
            alert('Nenhum desenho para salvar. Desenhe algo no mapa primeiro.');
            return;
          }
          
          try {
            // Create a feature collection from drawn layers
            const features = [];
            layers.forEach(layer => {
              if (layer.toGeoJSON) {
                const geoJson = layer.toGeoJSON();
                if (layer.feature && layer.feature.properties) {
                  geoJson.properties = { ...layer.feature.properties };
                }
                features.push(geoJson);
              }
            });
            
            if (features.length === 0) {
              throw new Error('Nenhum desenho v√°lido para salvar.');
            }
            
            const featureCollection = {
              type: 'FeatureCollection',
              features: features
            };
            
            // Show save dialog
            const name = prompt('Nome da nova camada:', 'Meu Desenho');
            if (!name) return;
            
            // Send to server
            const response = await fetch('/sig/api/upload', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                name: name,
                data: featureCollection
              })
            });
            
            if (!response.ok) {
              const error = await response.text();
              throw new Error(error || 'Falha ao salvar o desenho');
            }
            
            const result = await response.json();
            alert('Desenho salvo com sucesso!');
            
            // Clear the drawn features
            editableGroup.clearLayers();
            
            // Reload the layers list
            if (typeof loadItems === 'function') {
              loadItems();
            }
            
          } catch (error) {
            console.error('Erro ao salvar desenho:', error);
            alert(`Erro: ${error.message}`);
          }
        });
      
      return div;
    };
    
    // Add the save button to the map
    saveControl.addTo(map);
    
    // Function to save the drawn features
    async function saveDrawnFeatures() {
      console.log('Saving drawn features...');
      console.log('Editable layers count:', editableGroup.getLayers().length);
      
      if (editableGroup.getLayers().length === 0) {
        console.log('No layers to save');
        alert('Nenhum desenho para salvar. Desenhe algo no mapa primeiro.');
        return;
      }
      
      try {
        // Create a custom modal for better UX
        const modalHtml = `
          <div class="modal fade" id="saveLayerModal" tabindex="-1" aria-labelledby="saveLayerModalLabel" aria-hidden="true">
            <div class="modal-dialog">
              <div class="modal-content">
                <div class="modal-header">
                  <h5 class="modal-title" id="saveLayerModalLabel">Salvar Desenho</h5>
                  <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
                </div>
                <div class="modal-body">
                  <div class="mb-3">
                    <label for="layerName" class="form-label">Nome da Camada</label>
                    <input type="text" class="form-control" id="layerName" value="Meu Desenho">
                  </div>
                </div>
                <div class="modal-footer">
                  <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                  <button type="button" class="btn btn-primary" id="confirmSave">Salvar</button>
                </div>
              </div>
            </div>
          </div>
        `;
        
        // Add modal to the page if it doesn't exist
        if (!document.getElementById('saveLayerModal')) {
          document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        // Show the modal
        const modal = new bootstrap.Modal(document.getElementById('saveLayerModal'));
        modal.show();
        
        // Focus the input field
        document.getElementById('layerName').focus();
        
        // Wait for user to click Save or Cancel
        return new Promise((resolve) => {
          document.getElementById('confirmSave').onclick = async () => {
            const name = document.getElementById('layerName').value.trim();
            if (!name) {
              alert('Por favor, insira um nome para a camada.');
              return;
            }
            
            modal.hide();
            await processSave(name);
            resolve();
          };
          
          // Also handle Enter key in the input field
          document.getElementById('layerName').onkeydown = (e) => {
            if (e.key === 'Enter') {
              document.getElementById('confirmSave').click();
            }
          };
        });
        
      } catch (error) {
        console.error('Error in save dialog:', error);
        alert('Erro ao abrir a caixa de di√°logo de salvamento.');
      }
    }
    
    // Process the save operation
    async function processSave(name) {
      console.log('Processing save with name:', name);
      
      if (!name) {
        console.log('No name provided for save');
        return;
      }
      
      // Create a feature collection from drawn layers
      const features = [];
      editableGroup.getLayers().forEach(layer => {
        if (layer.toGeoJSON) {
          const geoJson = layer.toGeoJSON();
          // Preserve any properties that were added to the feature
          if (layer.feature && layer.feature.properties) {
            geoJson.properties = { ...layer.feature.properties };
          }
          features.push(geoJson);
        }
      });
      
      if (features.length === 0) {
        alert('Nenhum desenho v√°lido para salvar.');
        return;
      }
      
      const featureCollection = {
        type: 'FeatureCollection',
        features: features
      };
      
      try {
        // Send to server
        const response = await fetch('/sig/api/upload', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            name: name,
            data: featureCollection
          })
        });
        
        if (!response.ok) {
          const error = await response.text();
          throw new Error(error || 'Falha ao salvar o desenho');
        }
        
        const result = await response.json();
        alert('Desenho salvo com sucesso!');
        
        // Clear the drawn features
        editableGroup.clearLayers();
        
        // Reload the layers list
        loadItems();
        
      } catch (error) {
        console.error('Error saving drawing:', error);
        alert(`Erro ao salvar o desenho: ${error.message}`);
      }
    }
    
    // Function to initialize the save button handler
    function initSaveButton() {
      // Try to find the save button in the edit control
      const saveButtons = document.querySelectorAll('.leaflet-draw-actions a.leaflet-draw-save');
      
      if (saveButtons.length > 0) {
        // Use the first matching button
        saveButton = saveButtons[0];
        
        if (!saveButton._initialized) {
          console.log('Initializing save button:', saveButton);
          
          // Mark as initialized to prevent multiple bindings
          saveButton._initialized = true;
          
          // Store the original click handler if it exists
          const originalClick = saveButton.onclick;
          
          // Create a new click handler
          const handleSaveClick = async (e) => {
            console.log('Save button clicked');
            
            // Check if we're in drawing mode
            if (isDrawingMode) {
              e.preventDefault();
              e.stopPropagation();
              console.log('Handling save for drawing mode');
              
              try {
                await saveDrawnFeatures();
                // After saving, exit drawing mode
                if (L.Draw && L.Draw.getCurrentInstance()) {
                  L.Draw.getCurrentInstance().disable();
                }
              } catch (error) {
                console.error('Error saving drawing:', error);
              }
            } else if (originalClick) {
              // Call the original handler for normal save operations
              console.log('Using original save handler');
              return originalClick.call(this, e);
            }
          };
          
          // Add our click handler as a secondary handler
          saveButton.addEventListener('click', handleSaveClick);
          
          // Also handle Enter key for accessibility
          saveButton.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              handleSaveClick(e);
            }
          });
          
          console.log('Save button initialized');
        }
      } else {
        console.log('Save button not found, will retry...');
        // Try again after a short delay if the button isn't found yet
        setTimeout(initSaveButton, 500);
      }
    }
    
    // Initialize the save button when the document is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize save button
      initSaveButton();
      
      // Also try initializing when the edit control is shown
      map.on('draw:drawstart', function() {
        isDrawingMode = true;
        console.log('Drawing mode: started');
        // Re-initialize the save button to make sure we have the latest reference
        setTimeout(initSaveButton, 100);
      });
      
      map.on('draw:drawstop', function() {
        isDrawingMode = false;
        console.log('Drawing mode: stopped');
      });
    });
    
    // Update drawing mode state when draw controls are used
    map.on('draw:drawstart', function() {
      isDrawingMode = true;
      console.log('Drawing mode: started');
    });
    
    map.on('draw:drawstop', function() {
      isDrawingMode = false;
      console.log('Drawing mode: stopped');
    });

    // My GeoJSON layers state
    const userLayers = new Map(); // id -> layer
    const layerStyles = new Map(); // id -> style options
    let currentItems = [];
    let selectedCol = null; // atributo selecionado no modal
    let currentBase = 'road';

    function renderList() {
      const list = document.getElementById('layers-list');
      const no = document.getElementById('no-layers');
      const badge = document.getElementById('layer-count');
      const q = (document.getElementById('layer-search')?.value || '').toLowerCase();
      list.innerHTML = '';
      const items = q ? currentItems.filter(it => (it.name || '').toLowerCase().includes(q)) : currentItems;
      if (!items.length) {
        no.style.display = 'block';
        if (badge) badge.textContent = String(currentItems.length);
        return;
      } else {
        no.style.display = 'none';
        if (badge) badge.textContent = String(currentItems.length);
      }
      items.forEach(item => {
        const li = document.createElement('li');
        const label = document.createElement('div');
        label.className = 'item-label';
        const chk = document.createElement('input');
        chk.className = 'form-check-input me-2';
        chk.type = 'checkbox';
        chk.checked = true;
        chk.addEventListener('change', () => {
          const layer = userLayers.get(item.id);
          if (!layer) return;
          if (chk.checked) { layer.addTo(map); } else { map.removeLayer(layer); }
        });
        label.appendChild(chk);
        const nameEl = document.createElement('span');
        nameEl.className = 'name';
        nameEl.textContent = item.name;
        label.appendChild(nameEl);
        li.appendChild(label);
        const actions = document.createElement('div');
        actions.className = 'item-actions';
        const btnZoom = document.createElement('button');
        btnZoom.type = 'button';
        btnZoom.className = 'btn btn-ico btn-outline-secondary';
        btnZoom.setAttribute('data-bs-toggle', 'tooltip');
        btnZoom.setAttribute('data-bs-placement', 'top');
        btnZoom.setAttribute('title', 'Zoom na camada');
        btnZoom.innerHTML = '<i class="fa-solid fa-magnifying-glass"></i>';
        btnZoom.addEventListener('click', () => {
          const layer = userLayers.get(item.id);
          if (!layer) return;
          try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch(e) {}
        });
        const btnEdit = document.createElement('button');
        btnEdit.type = 'button';
        btnEdit.className = 'btn btn-ico btn-outline-secondary';
        btnEdit.setAttribute('data-bs-toggle', 'tooltip');
        btnEdit.setAttribute('data-bs-placement', 'top');
        btnEdit.setAttribute('title', 'Editar geometria');
        btnEdit.innerHTML = '<i class="fa-solid fa-pen"></i>';
        btnEdit.addEventListener('click', () => { startEdit(item.id); });
        const btnTable = document.createElement('button');
        btnTable.type = 'button';
        btnTable.className = 'btn btn-ico btn-outline-secondary';
        btnTable.setAttribute('data-bs-toggle', 'tooltip');
        btnTable.setAttribute('data-bs-placement', 'top');
        btnTable.setAttribute('title', 'Tabela de atributos');
        btnTable.innerHTML = '<i class="fa-solid fa-table"></i>';
        btnTable.addEventListener('click', () => { openAttrTable(item.id); });
        const btnStyle = document.createElement('button');
        btnStyle.type = 'button';
        btnStyle.className = 'btn btn-ico btn-outline-secondary';
        btnStyle.setAttribute('data-bs-toggle', 'tooltip');
        btnStyle.setAttribute('data-bs-placement', 'top');
        btnStyle.setAttribute('title', 'Estilo da camada');
        btnStyle.innerHTML = '<i class="fa-solid fa-palette"></i>';
        actions.appendChild(btnZoom);
        actions.appendChild(btnEdit);
        actions.appendChild(btnTable);
        actions.appendChild(btnStyle);
        li.appendChild(actions);
        btnStyle.addEventListener('click', () => { openStyleModal(item.id); });
        list.appendChild(li);
      });
    }

    function addOrReplaceLayer(item) {
      // remove existing
      const existing = userLayers.get(item.id);
      if (existing) { map.removeLayer(existing); editableGroup.removeLayer(existing); }
      const baseStyle = layerStyles.get(item.id) || { color: '#0d6efd', weight: 2, fillColor: '#0d6efd', fillOpacity: 0.2 };
      const layer = L.geoJSON(item.data, { style: baseStyle }).bindPopup(`<strong>${item.name}</strong>`);
      userLayers.set(item.id, layer);
      layer.addTo(map);
      editableGroup.addLayer(layer);
      return layer;
    }

    function fitToAll() {
      const group = L.featureGroup([...userLayers.values()]);
      if (group.getLayers().length) { map.fitBounds(group.getBounds(), { padding: [20, 20] }); }
    }

    function loadItems(onlyId) {
      if (onlyId) {
        return fetch(`{{ url_for('sig.api_get_file', file_id=0) }}`.replace(/0$/, String(onlyId)))
          .then(r => r.ok ? r.json() : Promise.reject())
          .then(item => {
            currentItems = [item];
            addOrReplaceLayer(item);
            renderList();
            try { const layer = userLayers.get(item.id); if (layer) map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch(e) {}
          })
          .catch(() => {});
      } else {
        return fetch("{{ url_for('sig.api_my_geojsons') }}")
          .then(r => r.json())
          .then(items => {
            currentItems = Array.isArray(items) ? items : [];
            currentItems.forEach(addOrReplaceLayer);
            renderList();
            fitToAll();
          })
          .catch(() => {});
      }
    }

    // Basemap switching
    document.querySelectorAll('input[name="basemap"]').forEach(r => {
      r.addEventListener('change', () => {
        Object.values(baseLayers).forEach(l => { try { map.removeLayer(l); } catch(e){} });
        const val = r.value;
        currentBase = val;
        baseLayers[val].addTo(map);
      });
    });

    document.getElementById('upload-form').addEventListener('submit', async (ev) => {
      ev.preventDefault();
      const form = ev.currentTarget;
      const fd = new FormData(form);
      const resp = await fetch("{{ url_for('sig.api_upload') }}", { method: 'POST', body: fd });
      if (resp.ok) {
        const saved = await resp.json();
        currentItems.push(saved);
        addOrReplaceLayer(saved);
        renderList();
        try { const layer = userLayers.get(saved.id); if (layer) map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch(e) {}
        form.reset();
      } else {
        alert('Falha ao enviar arquivo');
      }
    });

    // Toggle sidebar
    document.getElementById('btn-toggle-sidebar').addEventListener('click', () => {
      const wrapper = document.querySelector('.map-wrapper');
      wrapper.classList.toggle('collapsed');
      const open = !wrapper.classList.contains('collapsed');
      document.getElementById('icon-open').style.display = open ? '' : 'none';
      document.getElementById('icon-closed').style.display = open ? 'none' : '';
      setTimeout(() => map.invalidateSize(), 220);
    });

    // Back button control
    const BackControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function () {
        const container = L.DomUtil.create('div', 'leaflet-bar');
        const btn = L.DomUtil.create('a', '', container);
        btn.innerHTML = '‚Üê';
        btn.href = "{{ url_for('sig.files') }}";
        return container;
      }
    });
    map.addControl(new BackControl());

    // --- Edit session control (Salvar / Cancelar) ---
    const EditSessionControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function () {
        const container = L.DomUtil.create('div', 'leaflet-bar');
        container.style.display = 'none';
        const btnSave = L.DomUtil.create('a', '', container); btnSave.innerHTML = 'üíæ'; btnSave.title = 'Salvar edi√ß√£o';
        const btnCancel = L.DomUtil.create('a', '', container); btnCancel.innerHTML = '‚úñ'; btnCancel.title = 'Cancelar edi√ß√£o';
        btnSave.href = '#'; btnCancel.href = '#';
        L.DomEvent.on(btnSave, 'click', (e) => { L.DomEvent.stop(e); onSaveEdits(); });
        L.DomEvent.on(btnCancel, 'click', (e) => { L.DomEvent.stop(e); onCancelEdits(); });
        container.setAttribute('data-visible', 'false');
        container.setAttribute('id', 'edit-session-ctl');
        return container;
      },
      setVisible(v) {
        const c = document.getElementById('edit-session-ctl');
        if (c) c.style.display = v ? '' : 'none';
      }
    });
    const editSessionControl = new EditSessionControl();
    map.addControl(editSessionControl);

    let editingItemId = null;
    let originalGeoJSON = null;
    let editedDirty = false;
    const apiUpdateBase = "{{ url_for('sig.api_update_file', file_id=0) }}"; // e.g. /sig/api/files/0
    function updateUrl(id) { return apiUpdateBase.replace(/0$/, String(id)); }

    map.on('draw:edited', () => { editedDirty = true; });

    function enableDrawEditMode() {
      try {
        if (drawControl && drawControl._toolbars && drawControl._toolbars.edit && drawControl._toolbars.edit._modes.edit) {
          drawControl._toolbars.edit._modes.edit.handler.enable();
        }
      } catch (e) {}
    }

    function disableDrawEditMode() {
      try {
        if (drawControl && drawControl._toolbars && drawControl._toolbars.edit && drawControl._toolbars.edit._modes.edit) {
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
      } catch (e) {}
    }

    function startEdit(itemId) {
      if (editingItemId && editingItemId !== itemId) {
        alert('J√° existe uma edi√ß√£o em andamento. Salve ou cancele antes de editar outra camada.');
        return;
      }
      const item = currentItems.find(it => it.id === itemId);
      const layer = userLayers.get(itemId);
      if (!item || !layer) return;
      // snapshot original
      originalGeoJSON = JSON.parse(JSON.stringify(item.data));
      editingItemId = itemId;
      editedDirty = false;
      // isolate in editable group (ensure child vectors are target of edit)
      editableGroup.clearLayers();
      if (typeof layer.getLayers === 'function') {
        layer.getLayers().forEach(ch => editableGroup.addLayer(ch));
      } else {
        editableGroup.addLayer(layer);
      }
      try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch (e) {}
      enableDrawEditMode();
      editSessionControl.setVisible(true);
    }

    async function onSaveEdits() {
      if (!editingItemId) return;
      const layer = userLayers.get(editingItemId);
      if (!layer) { onCancelEdits(); return; }
      const updated = layer.toGeoJSON();
      try {
        const resp = await fetch(updateUrl(editingItemId), {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ data: updated })
        });
        
        if (!resp.ok) {
          const msg = await resp.text();
          alert('Falha ao salvar: ' + msg);
          return;
        }
        
        const saved = await resp.json();
        // update local state
        const idx = currentItems.findIndex(it => it.id === editingItemId);
        if (idx >= 0) currentItems[idx] = saved;
        // replace layer with saved data to ensure consistency
        addOrReplaceLayer(saved);
        finishEditSession();
        renderList();
      } catch (e) {
        alert('Erro inesperado ao salvar.');
      }
    }

    function onCancelEdits() {
      if (!editingItemId) return;
      // restore original geometry
      const restored = { id: editingItemId, name: (currentItems.find(it => it.id === editingItemId) || {}).name || 'Sem nome', data: originalGeoJSON };
      addOrReplaceLayer(restored);
      finishEditSession();
    }

    function finishEditSession() {
      disableDrawEditMode();
      editSessionControl.setVisible(false);
      editingItemId = null;
      originalGeoJSON = null;
      editedDirty = false;
      // keep editableGroup containing all layers again
      editableGroup.clearLayers();
      [...userLayers.values()].forEach(l => editableGroup.addLayer(l));
    }

    // ---------- Attribute table (properties) ----------
    let attrItemId = null;
    function unionPropertyKeys(fc) {
      const keys = new Set();
      if (fc && fc.type === 'FeatureCollection' && Array.isArray(fc.features)) {
        fc.features.forEach(f => {
          const props = (f && f.properties) || {};
          Object.keys(props).forEach(k => keys.add(k));
        });
      }
      return Array.from(keys);
    }

    function buildAttrTable(item) {
      const table = document.getElementById('attr-table');
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      thead.innerHTML = '';
      tbody.innerHTML = '';
      selectedCol = null;
      const data = item.data;
      if (!data || data.type !== 'FeatureCollection' || !Array.isArray(data.features)) {
        thead.innerHTML = '<tr><th class="text-muted">Sem atributos (n√£o √© FeatureCollection)</th></tr>';
        return;
      }
      const cols = unionPropertyKeys(data);
      const trh = document.createElement('tr');
      cols.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        th.tabIndex = 0;
        th.addEventListener('click', () => { selectedCol = col; [...thead.querySelectorAll('th')].forEach(x=>x.classList.remove('table-primary')); th.classList.add('table-primary'); });
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      data.features.forEach((f, idx) => {
        const tr = document.createElement('tr');
        cols.forEach(col => {
          const td = document.createElement('td');
          const val = (f.properties && f.properties[col] !== undefined) ? f.properties[col] : '';
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'form-control form-control-sm';
          input.value = String(val);
          input.dataset.row = String(idx);
          input.dataset.col = col;
          td.appendChild(input);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    }

    function openAttrTable(itemId) {
      const item = currentItems.find(it => it.id === itemId);
      if (!item) return;
      attrItemId = itemId;
      document.getElementById('attrModalLabel').textContent = `Tabela de atributos ‚Ä¢ ${item.name}`;
      buildAttrTable(item);
      const modal = new bootstrap.Modal(document.getElementById('attrModal'));
      modal.show();
    }

    document.getElementById('btn-add-col').addEventListener('click', () => {
      const name = prompt('Nome do novo campo:');
      if (!name) return;
      const item = currentItems.find(it => it.id === attrItemId);
      if (!item || item.data.type !== 'FeatureCollection') return;
      // add new column to UI and set empty values
      const cols = unionPropertyKeys(item.data);
      if (cols.includes(name)) { alert('Campo j√° existe.'); return; }
      item.data.features.forEach(f => { if (!f.properties) f.properties = {}; f.properties[name] = ''; });
      buildAttrTable(item);
    });

    document.getElementById('btn-del-col').addEventListener('click', () => {
      if (!selectedCol) { alert('Selecione um cabe√ßalho de coluna primeiro.'); return; }
      const ok = confirm(`Remover campo "${selectedCol}" de todos os registros?`);
      if (!ok) return;
      const item = currentItems.find(it => it.id === attrItemId);
      if (!item || item.data.type !== 'FeatureCollection') return;
      item.data.features.forEach(f => { if (f && f.properties) { delete f.properties[selectedCol]; } });
      buildAttrTable(item);
    });

    document.getElementById('btn-save-attrs').addEventListener('click', async () => {
      const item = currentItems.find(it => it.id === attrItemId);
      if (!item || item.data.type !== 'FeatureCollection') return;
      // read inputs back into item.data
      document.querySelectorAll('#attr-table tbody input').forEach(inp => {
        const row = parseInt(inp.dataset.row, 10);
        const col = inp.dataset.col;
        const f = item.data.features[row];
        if (!f.properties) f.properties = {};
        f.properties[col] = inp.value;
      });
      // Local only (map snapshot), do not persist original file here
      const idx = currentItems.findIndex(it => it.id === item.id);
      if (idx >= 0) currentItems[idx].data = item.data;
      addOrReplaceLayer(currentItems[idx]);
      alert('Atributos atualizados neste mapa. Lembre-se de usar "Salvar mapa" para manter estas altera√ß√µes.');
    });

    // Initial load
    (function(){
      const sp = new URLSearchParams(location.search);
      const onlyId = parseInt(sp.get('only') || '', 10);
      const isPublic = sp.get('public') === '1';
      if (!isNaN(onlyId)) {
        loadItems(onlyId);
      } else {
        loadItems().then(() => {
          const focusId = parseInt(sp.get('focus') || '', 10);
          if (!isNaN(focusId)) {
            const layer = userLayers.get(focusId);
            if (layer) {
              try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch (e) {}
            }
          }
        });
      }
      // Sidebar collapsible sections
      document.querySelectorAll('[data-collapse]').forEach(btn => {
        btn.addEventListener('click', () => {
          const sel = btn.getAttribute('data-collapse');
          const tgt = document.querySelector(sel);
          if (!tgt) return;
          const isHidden = getComputedStyle(tgt).display === 'none';
          tgt.style.display = isHidden ? '' : 'none';
          btn.textContent = isHidden ? 'Ocultar' : 'Mostrar';
        });
      });
      // Search in layers
      const searchEl = document.getElementById('layer-search');
      if (searchEl) searchEl.addEventListener('input', renderList);
    // Removida a funcionalidade de salvar mapa
    if (isPublic) {
      // Ocultar upload no modo p√∫blico
      document.getElementById('sec-upload')?.closest('.section')?.remove();
    }
    // Dropzone behaviors
    const dz = document.getElementById('dropzone');
    const finput = document.getElementById('file-input');
    if (dz && finput) {
      dz.addEventListener('click', () => finput.click());
      dz.addEventListener('dragover', (e) => { e.preventDefault(); dz.classList.add('dragover'); });
      dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
      dz.addEventListener('drop', (e) => {
        e.preventDefault();
        dz.classList.remove('dragover');
      });
    }
    // Show upload on demand
    const btnShowUpload = document.getElementById('btn-show-upload');
    if (btnShowUpload) btnShowUpload.addEventListener('click', () => {
      const up = document.getElementById('sec-upload');
      if (up) up.style.display = '';
    });
    // Initialize tooltips (Bootstrap 5)
    const tSel = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tSel.forEach(function (el) { try { new bootstrap.Tooltip(el); } catch(e){} });
    })();
  </script>

  <!-- Style Modal -->
  <div class="modal fade" id="styleModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-sm modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Estilo da camada</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="row g-2">
            <div class="col-6">
              <label class="form-label mb-0 small">Borda</label>
              <input type="color" class="form-control form-control-sm" id="st-color" />
            </div>
            <div class="col-6">
              <label class="form-label mb-0 small">Espessura</label>
              <input type="number" min="1" max="10" class="form-control form-control-sm" id="st-weight" value="2" />
            </div>
            <div class="col-6">
              <label class="form-label mb-0 small">Preenchimento</label>
              <input type="color" class="form-control form-control-sm" id="st-fillColor" />
            </div>
            <div class="col-6">
              <label class="form-label mb-0 small">Opacidade</label>
              <input type="number" step="0.1" min="0" max="1" class="form-control form-control-sm" id="st-fillOpacity" value="0.2" />
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-outline-secondary btn-sm" data-bs-dismiss="modal">Fechar</button>
          <button type="button" class="btn btn-primary btn-sm" id="btn-apply-style">Aplicar</button>
        </div>
      </div>
    </div>
  </div>
  <script>
    let styleItemId = null;
    function openStyleModal(itemId) {
      styleItemId = itemId;
      const s = layerStyles.get(itemId) || { color: '#0d6efd', weight: 2, fillColor: '#0d6efd', fillOpacity: 0.2 };
      document.getElementById('st-color').value = s.color || '#0d6efd';
      document.getElementById('st-weight').value = s.weight || 2;
      document.getElementById('st-fillColor').value = s.fillColor || '#0d6efd';
      document.getElementById('st-fillOpacity').value = typeof s.fillOpacity === 'number' ? s.fillOpacity : 0.2;
      const m = new bootstrap.Modal(document.getElementById('styleModal'));
      m.show();
    }
    document.getElementById('btn-apply-style').addEventListener('click', () => {
      if (!styleItemId) return;
      const s = {
        color: document.getElementById('st-color').value,
        weight: Number(document.getElementById('st-weight').value || 2),
        fillColor: document.getElementById('st-fillColor').value,
        fillOpacity: Number(document.getElementById('st-fillOpacity').value || 0.2),
      };
      layerStyles.set(styleItemId, s);
      const layer = userLayers.get(styleItemId);
      try { if (layer && layer.setStyle) layer.setStyle(s); } catch(e){}
      const modalEl = document.getElementById('styleModal');
      bootstrap.Modal.getInstance(modalEl)?.hide();
      styleItemId = null;
    });
  </script>
{% endblock %}

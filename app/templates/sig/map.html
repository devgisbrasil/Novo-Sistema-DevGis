{% extends 'base.html' %}
{% block content %}
  <style>
    html, body { height: 100%; }
    main.container { max-width: 100% !important; padding: 0; }
    .map-wrapper { display: flex; height: calc(100vh - 64px); width: 100%; }
    .sidebar { width: 300px; background: #fff; border-right: 1px solid #e5e7eb; padding: 12px; overflow: auto; }
    .sidebar h2 { font-size: 1rem; margin: 0 0 8px; font-weight: 700; }
    .sidebar .section { margin-bottom: 14px; }
    .sidebar .muted { color: #6c757d; font-size: .9rem; }
    .sidebar .list { list-style: none; padding: 0; margin: 0; }
    .sidebar .list li { display: flex; align-items: center; justify-content: space-between; padding: 6px 0; border-bottom: 1px dashed #eee; }
    #map { flex: 1; }
    /* Enhancements: spacing, actions, toggle */
    .map-wrapper { position: relative; }
    .sidebar .list li { gap: 8px; }
    .sidebar .item-actions { display: flex; gap: 6px; }
    .sidebar .btn-icon { border: 1px solid #e5e7eb; background: #f8f9fa; padding: 2px 6px; border-radius: 4px; font-size: 12px; cursor: pointer; }
    .sidebar .btn-icon:hover { background: #e9ecef; }
    .sidebar-toggle { position: absolute; left: 300px; top: 12px; z-index: 500; transform: translateX(-50%); }
    .sidebar-toggle .btn { padding: 8px 10px; font-size: 14px; border-radius: 999px; box-shadow: 0 2px 8px rgba(0,0,0,.15); }
    .sidebar-toggle .btn.btn-primary { background: var(--brand-500); border-color: var(--brand-600); }
    .sidebar-toggle .btn.btn-primary:hover { background: var(--brand-600); border-color: var(--brand-700); }
    .collapsed .sidebar { width: 0; padding: 0; border-right: none; }
    .collapsed .sidebar-toggle { left: 0; transform: translateX(-50%); }
    .leaflet-top.leaflet-right { margin-right: 10px; }
    .leaflet-top.leaflet-left { margin-left: 10px; }
  </style>
  <div class="map-wrapper">
    <aside class="sidebar">
      <div class="section">
        <h2>Camada base</h2>
        <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-road" value="road" checked><label class="form-check-label" for="bm-road">Rodoviário</label></div>
        <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-sat" value="sat"><label class="form-check-label" for="bm-sat">Satélite</label></div>
        <div class="form-check"><input class="form-check-input" type="radio" name="basemap" id="bm-relief" value="relief"><label class="form-check-label" for="bm-relief">Relevo</label></div>
      </div>
      <div class="section">
        <h2>Meus GeoJSONs</h2>
        <ul id="layers-list" class="list"></ul>
        <p class="muted" id="no-layers" style="display:none">Nenhum arquivo. Envie um abaixo.</p>
      </div>
      <div class="section">
        <h2>Novo GeoJSON</h2>
        <form id="upload-form">
          <div class="mb-2"><input class="form-control form-control-sm" type="text" name="name" placeholder="Nome opcional" /></div>
          <div class="mb-2"><input class="form-control form-control-sm" type="file" name="file" accept=".json,.geojson,application/geo+json,application/json" required /></div>
          <button class="btn btn-primary btn-sm" type="submit">Carregar</button>
          <div class="form-text">Somente você verá/manipulará seus arquivos.</div>
        </form>
      </div>
    </aside>
    <div id="map"></div>
    <div class="sidebar-toggle">
      <button type="button" id="btn-toggle-sidebar" class="btn btn-primary" title="Recolher/Expandir menu">
        <span id="icon-open">«</span><span id="icon-closed" style="display:none">»</span>
      </button>
    </div>
  </div>

  <!-- Modal: Tabela de Atributos -->
  <div class="modal fade" id="attrModal" tabindex="-1" aria-labelledby="attrModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="attrModalLabel">Tabela de atributos</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="d-flex gap-2 mb-2">
            <button class="btn btn-outline-primary btn-sm" id="btn-add-col">Adicionar campo</button>
            <button class="btn btn-outline-danger btn-sm" id="btn-del-col">Remover campo selecionado</button>
            <span class="text-muted">Dica: clique em um cabeçalho para selecionar a coluna.</span>
          </div>
          <div class="table-responsive">
            <table class="table table-bordered table-sm align-middle" id="attr-table">
              <thead></thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
          <button type="button" class="btn btn-primary" id="btn-save-attrs">Salvar alterações</button>
        </div>
      </div>
    </div>
  </div>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script>
    const map = L.map('map', { zoomControl: false });
    L.control.zoom({ position: 'topright' }).addTo(map);
    // Base layers
    const baseLayers = {
      road: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'}),
      sat: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {maxZoom: 17, attribution: 'Tiles &copy; OpenTopoMap'}),
      relief: L.tileLayer('https://{s}.tile.stamen.com/terrain/{z}/{x}/{y}.jpg', {maxZoom: 18, attribution: 'Stamen Terrain'})
    };
    baseLayers.road.addTo(map);

    const editableGroup = new L.FeatureGroup();
    map.addLayer(editableGroup);
    const drawControl = new L.Control.Draw({
      position: 'topleft',
      draw: { polygon: true, polyline: true, rectangle: true, circle: false, marker: true },
      edit: { featureGroup: editableGroup }
    });
    map.addControl(drawControl);
    map.on(L.Draw.Event.CREATED, function (e) { editableGroup.addLayer(e.layer); });

    // My GeoJSON layers state
    const userLayers = new Map(); // id -> layer
    let currentItems = [];
    let selectedCol = null; // atributo selecionado no modal

    function renderList() {
      const list = document.getElementById('layers-list');
      const no = document.getElementById('no-layers');
      list.innerHTML = '';
      if (!currentItems.length) { no.style.display = 'block'; return; } else { no.style.display = 'none'; }
      currentItems.forEach(item => {
        const li = document.createElement('li');
        const label = document.createElement('label');
        label.className = 'form-check-label d-flex align-items-center gap-2 flex-grow-1';
        const chk = document.createElement('input');
        chk.className = 'form-check-input me-2';
        chk.type = 'checkbox';
        chk.checked = true;
        chk.addEventListener('change', () => {
          const layer = userLayers.get(item.id);
          if (!layer) return;
          if (chk.checked) { layer.addTo(map); } else { map.removeLayer(layer); }
        });
        label.appendChild(chk);
        label.appendChild(document.createTextNode(item.name));
        li.appendChild(label);
        const actions = document.createElement('div');
        actions.className = 'item-actions';
        const btnZoom = document.createElement('button');
        btnZoom.type = 'button';
        btnZoom.className = 'btn-icon';
        btnZoom.textContent = 'Zoom';
        btnZoom.addEventListener('click', () => {
          const layer = userLayers.get(item.id);
          if (layer) {
            try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch (e) {}
          }
        });
        const btnEdit = document.createElement('button');
        btnEdit.type = 'button';
        btnEdit.className = 'btn-icon';
        btnEdit.textContent = 'Editar';
        btnEdit.addEventListener('click', () => { startEdit(item.id); });
        const btnTable = document.createElement('button');
        btnTable.type = 'button';
        btnTable.className = 'btn-icon';
        btnTable.textContent = 'Tabela';
        btnTable.addEventListener('click', () => { openAttrTable(item.id); });
        actions.appendChild(btnZoom);
        actions.appendChild(btnEdit);
        actions.appendChild(btnTable);
        li.appendChild(actions);
        list.appendChild(li);
      });
    }

    function addOrReplaceLayer(item) {
      // remove existing
      const existing = userLayers.get(item.id);
      if (existing) { map.removeLayer(existing); editableGroup.removeLayer(existing); }
      const layer = L.geoJSON(item.data, { style: { color: '#0d6efd' } }).bindPopup(`<strong>${item.name}</strong>`);
      userLayers.set(item.id, layer);
      layer.addTo(map);
      editableGroup.addLayer(layer);
      return layer;
    }

    function fitToAll() {
      const group = L.featureGroup([...userLayers.values()]);
      if (group.getLayers().length) { map.fitBounds(group.getBounds(), { padding: [20, 20] }); }
    }

    function loadItems(onlyId) {
      if (onlyId) {
        return fetch(`{{ url_for('sig.api_get_file', file_id=0) }}`.replace(/0$/, String(onlyId)))
          .then(r => r.ok ? r.json() : Promise.reject())
          .then(item => {
            currentItems = [item];
            addOrReplaceLayer(item);
            renderList();
            try { const layer = userLayers.get(item.id); if (layer) map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch(e) {}
          })
          .catch(() => {});
      } else {
        return fetch("{{ url_for('sig.api_my_geojsons') }}")
          .then(r => r.json())
          .then(items => {
            currentItems = Array.isArray(items) ? items : [];
            currentItems.forEach(addOrReplaceLayer);
            renderList();
            fitToAll();
          })
          .catch(() => {});
      }
    }

    // Basemap switching
    document.querySelectorAll('input[name="basemap"]').forEach(r => {
      r.addEventListener('change', () => {
        // remove all base layers then add selected
        Object.values(baseLayers).forEach(l => map.removeLayer(l));
        baseLayers[r.value].addTo(map);
      });
    });

    document.getElementById('upload-form').addEventListener('submit', async (ev) => {
      ev.preventDefault();
      const form = ev.currentTarget;
      const fd = new FormData(form);
      const resp = await fetch("{{ url_for('sig.api_upload') }}", { method: 'POST', body: fd });
      if (resp.ok) {
        const saved = await resp.json();
        currentItems.push(saved);
        addOrReplaceLayer(saved);
        renderList();
        try { const layer = userLayers.get(saved.id); if (layer) map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch(e) {}
        form.reset();
      } else {
        alert('Falha ao enviar arquivo');
      }
    });

    // Toggle sidebar
    document.getElementById('btn-toggle-sidebar').addEventListener('click', () => {
      const wrapper = document.querySelector('.map-wrapper');
      wrapper.classList.toggle('collapsed');
      const open = !wrapper.classList.contains('collapsed');
      document.getElementById('icon-open').style.display = open ? '' : 'none';
      document.getElementById('icon-closed').style.display = open ? 'none' : '';
      setTimeout(() => map.invalidateSize(), 220);
    });

    // Back button control
    const BackControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function () {
        const container = L.DomUtil.create('div', 'leaflet-bar');
        const btn = L.DomUtil.create('a', '', container);
        btn.innerHTML = '←';
        btn.href = "{{ url_for('sig.files') }}";
        return container;
      }
    });
    map.addControl(new BackControl());

    // --- Edit session control (Salvar / Cancelar) ---
    const EditSessionControl = L.Control.extend({
      options: { position: 'topleft' },
      onAdd: function () {
        const container = L.DomUtil.create('div', 'leaflet-bar');
        container.style.display = 'none';
        const btnSave = L.DomUtil.create('a', '', container); btnSave.innerHTML = '💾'; btnSave.title = 'Salvar edição';
        const btnCancel = L.DomUtil.create('a', '', container); btnCancel.innerHTML = '✖'; btnCancel.title = 'Cancelar edição';
        btnSave.href = '#'; btnCancel.href = '#';
        L.DomEvent.on(btnSave, 'click', (e) => { L.DomEvent.stop(e); onSaveEdits(); });
        L.DomEvent.on(btnCancel, 'click', (e) => { L.DomEvent.stop(e); onCancelEdits(); });
        container.setAttribute('data-visible', 'false');
        container.setAttribute('id', 'edit-session-ctl');
        return container;
      },
      setVisible(v) {
        const c = document.getElementById('edit-session-ctl');
        if (c) c.style.display = v ? '' : 'none';
      }
    });
    const editSessionControl = new EditSessionControl();
    map.addControl(editSessionControl);

    let editingItemId = null;
    let originalGeoJSON = null;
    let editedDirty = false;
    const apiUpdateBase = "{{ url_for('sig.api_update_file', file_id=0) }}"; // e.g. /sig/api/files/0
    function updateUrl(id) { return apiUpdateBase.replace(/0$/, String(id)); }

    map.on('draw:edited', () => { editedDirty = true; });

    function enableDrawEditMode() {
      try {
        if (drawControl && drawControl._toolbars && drawControl._toolbars.edit && drawControl._toolbars.edit._modes.edit) {
          drawControl._toolbars.edit._modes.edit.handler.enable();
        }
      } catch (e) {}
    }

    function disableDrawEditMode() {
      try {
        if (drawControl && drawControl._toolbars && drawControl._toolbars.edit && drawControl._toolbars.edit._modes.edit) {
          drawControl._toolbars.edit._modes.edit.handler.disable();
        }
      } catch (e) {}
    }

    function startEdit(itemId) {
      if (editingItemId && editingItemId !== itemId) {
        alert('Já existe uma edição em andamento. Salve ou cancele antes de editar outra camada.');
        return;
      }
      const item = currentItems.find(it => it.id === itemId);
      const layer = userLayers.get(itemId);
      if (!item || !layer) return;
      // snapshot original
      originalGeoJSON = JSON.parse(JSON.stringify(item.data));
      editingItemId = itemId;
      editedDirty = false;
      // isolate in editable group (ensure child vectors are target of edit)
      editableGroup.clearLayers();
      if (typeof layer.getLayers === 'function') {
        layer.getLayers().forEach(ch => editableGroup.addLayer(ch));
      } else {
        editableGroup.addLayer(layer);
      }
      try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch (e) {}
      enableDrawEditMode();
      editSessionControl.setVisible(true);
    }

    async function onSaveEdits() {
      if (!editingItemId) return;
      const layer = userLayers.get(editingItemId);
      if (!layer) { onCancelEdits(); return; }
      const updated = layer.toGeoJSON();
      try {
        const resp = await fetch(updateUrl(editingItemId), {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ data: updated })
        });
        if (!resp.ok) {
          const msg = await resp.text();
          alert('Falha ao salvar: ' + msg);
          return;
        }
        const saved = await resp.json();
        // update local state
        const idx = currentItems.findIndex(it => it.id === editingItemId);
        if (idx >= 0) currentItems[idx] = saved;
        // replace layer with saved data to ensure consistency
        addOrReplaceLayer(saved);
        finishEditSession();
        renderList();
      } catch (e) {
        alert('Erro inesperado ao salvar.');
      }
    }

    function onCancelEdits() {
      if (!editingItemId) return;
      // restore original geometry
      const restored = { id: editingItemId, name: (currentItems.find(it => it.id === editingItemId) || {}).name || 'Sem nome', data: originalGeoJSON };
      addOrReplaceLayer(restored);
      finishEditSession();
    }

    function finishEditSession() {
      disableDrawEditMode();
      editSessionControl.setVisible(false);
      editingItemId = null;
      originalGeoJSON = null;
      editedDirty = false;
      // keep editableGroup containing all layers again
      editableGroup.clearLayers();
      [...userLayers.values()].forEach(l => editableGroup.addLayer(l));
    }

    // ---------- Attribute table (properties) ----------
    let attrItemId = null;
    function unionPropertyKeys(fc) {
      const keys = new Set();
      if (fc && fc.type === 'FeatureCollection' && Array.isArray(fc.features)) {
        fc.features.forEach(f => {
          const props = (f && f.properties) || {};
          Object.keys(props).forEach(k => keys.add(k));
        });
      }
      return Array.from(keys);
    }

    function buildAttrTable(item) {
      const table = document.getElementById('attr-table');
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody');
      thead.innerHTML = '';
      tbody.innerHTML = '';
      selectedCol = null;
      const data = item.data;
      if (!data || data.type !== 'FeatureCollection' || !Array.isArray(data.features)) {
        thead.innerHTML = '<tr><th class="text-muted">Sem atributos (não é FeatureCollection)</th></tr>';
        return;
      }
      const cols = unionPropertyKeys(data);
      const trh = document.createElement('tr');
      cols.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        th.tabIndex = 0;
        th.addEventListener('click', () => { selectedCol = col; [...thead.querySelectorAll('th')].forEach(x=>x.classList.remove('table-primary')); th.classList.add('table-primary'); });
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      data.features.forEach((f, idx) => {
        const tr = document.createElement('tr');
        cols.forEach(col => {
          const td = document.createElement('td');
          const val = (f.properties && f.properties[col] !== undefined) ? f.properties[col] : '';
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'form-control form-control-sm';
          input.value = String(val);
          input.dataset.row = String(idx);
          input.dataset.col = col;
          td.appendChild(input);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    }

    function openAttrTable(itemId) {
      const item = currentItems.find(it => it.id === itemId);
      if (!item) return;
      attrItemId = itemId;
      document.getElementById('attrModalLabel').textContent = `Tabela de atributos • ${item.name}`;
      buildAttrTable(item);
      const modal = new bootstrap.Modal(document.getElementById('attrModal'));
      modal.show();
    }

    document.getElementById('btn-add-col').addEventListener('click', () => {
      const name = prompt('Nome do novo campo:');
      if (!name) return;
      const item = currentItems.find(it => it.id === attrItemId);
      if (!item || item.data.type !== 'FeatureCollection') return;
      // add new column to UI and set empty values
      const cols = unionPropertyKeys(item.data);
      if (cols.includes(name)) { alert('Campo já existe.'); return; }
      item.data.features.forEach(f => { if (!f.properties) f.properties = {}; f.properties[name] = ''; });
      buildAttrTable(item);
    });

    document.getElementById('btn-del-col').addEventListener('click', () => {
      if (!selectedCol) { alert('Selecione um cabeçalho de coluna primeiro.'); return; }
      const ok = confirm(`Remover campo "${selectedCol}" de todos os registros?`);
      if (!ok) return;
      const item = currentItems.find(it => it.id === attrItemId);
      if (!item || item.data.type !== 'FeatureCollection') return;
      item.data.features.forEach(f => { if (f && f.properties) { delete f.properties[selectedCol]; } });
      buildAttrTable(item);
    });

    document.getElementById('btn-save-attrs').addEventListener('click', async () => {
      const item = currentItems.find(it => it.id === attrItemId);
      if (!item || item.data.type !== 'FeatureCollection') return;
      // read inputs back into item.data
      document.querySelectorAll('#attr-table tbody input').forEach(inp => {
        const row = parseInt(inp.dataset.row, 10);
        const col = inp.dataset.col;
        const f = item.data.features[row];
        if (!f.properties) f.properties = {};
        f.properties[col] = inp.value;
      });
      try {
        const resp = await fetch(updateUrl(item.id), { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ data: item.data }) });
        if (!resp.ok) { const msg = await resp.text(); alert('Falha ao salvar: ' + msg); return; }
        const saved = await resp.json();
        // update local state and layer
        const idx = currentItems.findIndex(it => it.id === item.id);
        if (idx >= 0) currentItems[idx] = saved;
        addOrReplaceLayer(saved);
        alert('Atributos salvos com sucesso.');
      } catch (e) {
        alert('Erro inesperado ao salvar atributos.');
      }
    });

    // Initial load
    (function(){
      const sp = new URLSearchParams(location.search);
      const onlyId = parseInt(sp.get('only') || '', 10);
      if (!isNaN(onlyId)) {
        loadItems(onlyId);
      } else {
        loadItems().then(() => {
          const focusId = parseInt(sp.get('focus') || '', 10);
          if (!isNaN(focusId)) {
            const layer = userLayers.get(focusId);
            if (layer) {
              try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch (e) {}
            }
          }
        });
      }
    })();
  </script>
{% endblock %}
